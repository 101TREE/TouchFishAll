<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>牛牛婚礼</title>
<style>
  html,body{margin:0;padding:0;overflow:hidden;background:#0b0c2f;}
  canvas{display:block;}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');
let W=innerWidth,H=innerHeight;
canvas.width=W;canvas.height=H;
window.addEventListener('resize',()=>{W=innerWidth;H=innerHeight;canvas.width=W;canvas.height=H;});

const rand=(a,b)=>a+Math.random()*(b-a);
const pick=a=>a[Math.floor(Math.random()*a.length)];
const groundYRatio=0.75;
const groundY=()=>H*groundYRatio;

const NAMES=['陈德立','李建','发哥','斌总','吴立森','海涛','金刚','赵国林','万业','大雕'];
const MSGS=[
  '我也要结婚！','祝你们白头偕老','永远幸福','牛牛啊，牛牛，怎么那么快',
  '我也想交女朋友，结婚','羡慕，我们都是羡慕怪','甜甜蜜蜜','携手到老'
];

// === STARS ===
let stars=[];
function initStars(){
  for(let i=0;i<250;i++){
    stars.push({
      xr:Math.random(),yr:Math.random()*0.5,
      r:Math.random()*1.2+0.3,
      alpha:Math.random()*0.8+0.2,
      dA:(Math.random()*0.006+0.002)*(Math.random()<0.5?-1:1)
    });
  }
}
initStars();

// === BACKGROUND ===
let grassSeed=Math.random()*1000;
function drawLake(){
  const top=H*0.65;
  const g=ctx.createLinearGradient(0,top,0,H);
  g.addColorStop(0,'rgba(255,255,255,0.14)');
  g.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle=g;ctx.fillRect(0,top,W,H-top);
}
function drawGrass(){
  const top=groundY();
  const grad=ctx.createLinearGradient(0,top,0,H);
  grad.addColorStop(0,'#2b4d2f');grad.addColorStop(1,'#162215');
  ctx.fillStyle=grad;ctx.fillRect(0,top,W,H-top);
  grassSeed+=0.001;
  for(let i=0;i<W;i+=6){
    const t1=Math.sin(i*0.02+grassSeed)*8;
    const t2=Math.sin(i*0.05+grassSeed*1.3)*5;
    const t3=(Math.abs((i*31)%7-3))*0.6*(Math.random()*0.4+0.8);
    const h=t1+t2+t3;
    ctx.strokeStyle=`rgb(${32+Math.floor(Math.random()*20)},${46+Math.floor(Math.random()*25)},${28+Math.floor(Math.random()*20)})`;
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(i,top);
    ctx.bezierCurveTo(i+h/2,top-h/2,i+h,top-h,i,top-h);
    ctx.stroke();
  }
}

// === CHERRY TREE ===
let fallenFlowers=[];
class CherryTree{
  constructor(xr,yr,heightRatio){
    this.xr=xr;this.yr=yr;this.heightRatio=heightRatio;
    this.flowers=[];this.lastFallTime=0;
    this.initFlowers();
  }
  initFlowers(){
    this.flowers=[];
    const crownH=this.heightRatio*H*0.6;
    const crownW=this.heightRatio*H*0.9;
    const cx=this.xr*W;const cy=this.yr*H-this.heightRatio*H;
    let attempts=0;
    while(this.flowers.length<420&&attempts<6000){
      attempts++;
      let u=Math.random()*2-1,v=Math.random()*2-1;
      let r=Math.sqrt(u*u+v*v);
      if(r>1)continue;
      if(r<(0.25+Math.random()*0.15)&&Math.random()<0.6)continue;
      const angle=Math.atan2(v,u);
      const radius=r*(0.5+Math.random()*0.55);
      const x=cx+Math.cos(angle)*radius*crownW;
      const y=cy+Math.sin(angle)*radius*crownH;
      const dist=Math.sqrt(((x-cx)*(x-cx))/(crownW*crownW)+((y-cy)*(y-cy))/(crownH*crownH));
      const alpha=0.35+0.65*(1-Math.min(1,dist));
      const sizeRatio=0.003+Math.random()*0.002;
      this.flowers.push({xr:x/W,yr:y/H,sizeRatio,alpha,phase:Math.random()*Math.PI*2});
    }
  }
  drawTrunk(){
    const x=this.xr*W,bottom=this.yr*H,h=this.heightRatio*H;
    const baseW=32*H/1080,topW=10*H/1080;
    ctx.save();
    for(let i=0;i<=18;i++){
      const t=i/18;
      const y1=bottom-h*t;
      const y2=bottom-h*(t+1/18);
      const lw=baseW*(1-t)+topW*t;
      ctx.strokeStyle='#5d3a1a';
      ctx.lineWidth=lw;
      ctx.beginPath();ctx.moveTo(x,y1);ctx.lineTo(x,y2);ctx.stroke();
    }
    ctx.restore();
  }
  drawFlowers(dt,time){
    for(const f of this.flowers){
      const dx=Math.cos(f.phase+time/800)*4*H/1080;
      const dy=Math.sin(f.phase+time/700)*2*H/1080;
      ctx.fillStyle=`rgba(255,182,193,${f.alpha})`;
      ctx.beginPath();
      ctx.arc(f.xr*W+dx,f.yr*H+dy,f.sizeRatio*H,0,Math.PI*2);
      ctx.fill();
    }
    if(time-this.lastFallTime>1000){
      if(this.flowers.length>0){
        const idx=Math.floor(Math.random()*this.flowers.length);
        const f=this.flowers[idx];
        fallenFlowers.push({x:f.xr*W,y:f.yr*H,size:f.sizeRatio*H,alpha:f.alpha,vy:0,birth:time,treeRef:this});
        this.flowers.splice(idx,1);
      }
      this.lastFallTime=time;
    }
  }
  addFlowerOnce(){
    const crownH=this.heightRatio*H*0.6,crownW=this.heightRatio*H*0.9;
    const cx=this.xr*W,cy=this.yr*H-this.heightRatio*H;
    for(let attempts=0;attempts<50;attempts++){
      let u=Math.random()*2-1,v=Math.random()*2-1;
      let r=Math.sqrt(u*u+v*v);
      if(r>1)continue;
      if(r<0.2&&Math.random()<0.6)continue;
      const angle=Math.atan2(v,u);
      const radius=r*(0.5+Math.random()*0.55);
      const x=cx+Math.cos(angle)*radius*crownW;
      const y=cy+Math.sin(angle)*radius*crownH;
      const dist=Math.sqrt(((x-cx)*(x-cx))/(crownW*crownW)+((y-cy)*(y-cy))/(crownH*crownH));
      const alpha=0.35+0.65*(1-Math.min(1,dist));
      const sizeRatio=0.002+Math.random()*0.002;
      this.flowers.push({xr:x/W,yr:y/H,sizeRatio,alpha,phase:Math.random()*Math.PI*2});
      break;
    }
  }
  draw(dt,time){this.drawTrunk();this.drawFlowers(dt,time);}
}
function updateAndDrawFallenFlowers(dt, time){
    const ground = groundY();
    for(let i=fallenFlowers.length-1;i>=0;i--){
        const f = fallenFlowers[i];

        // 初始化水平速度（微小漂移）和垂直速度（慢下落）
        if(f.vx === undefined) f.vx = rand(-0.01, 0.01) * W/1000; // 水平缓慢漂移
        if(f.vy === undefined) f.vy = rand(0.02, 0.05) * H/1000; // 初始下落很慢

        // 让花瓣逐渐加速下落（重力更小，减缓下落速度）
        const g = 0.0000001 * H; // 重力加速度，越小落得越慢
        if(f.y < ground){
            f.vy += g * dt;
            f.y += f.vy * dt;
            f.x += f.vx * dt;
        } else { 
            f.y = ground; // 到地面后固定
            f.vy = 0;
            f.vx = 0;
        }

        // 绘制花瓣
        ctx.fillStyle = `rgba(255,182,193,${f.alpha})`;
        ctx.beginPath();
        ctx.arc(f.x, f.y, Math.max(0.5,f.size), 0, Math.PI*2);
        ctx.fill();

        // 花瓣生命过长，可重新生成
        if(time - f.birth > 20000){ // 花瓣存在更久
            try{ f.treeRef.addFlowerOnce(); } catch(e){}
            fallenFlowers.splice(i,1);
        }
    }
}

// === TEXT SPLASH ===
let textSplashes=[];
function easeOutCubic(t){return 1-Math.pow(1-t,3);}
function createTextSplashesAt(x,y){
  const name=pick(NAMES),msg=pick(MSGS);
  const text=name+'：'+msg;
  const hue=Math.random()*360;
  const risePx=rand(18,48)*(H/900);
  const life=1400+Math.random()*1200;
  textSplashes.push({x,y,startY:y, rise:risePx,text,hue,life,birth:performance.now(),font:Math.max(12,Math.floor(H*0.018*(0.9+Math.random()*0.3)))});
}
function updateAndDrawTextSplashes(dt,now){
  for(let i=textSplashes.length-1;i>=0;i--){
    const s=textSplashes[i];
    const age=now-s.birth,t=Math.max(0,Math.min(1,age/s.life));
    const eased=easeOutCubic(t);
    const y=s.startY-s.rise*eased;
    const alpha=1-t;
    ctx.globalAlpha=alpha;
    ctx.fillStyle=`hsl(${s.hue} 80% 70%)`;
    ctx.font=`bold ${s.font}px sans-serif`;
    ctx.textBaseline='bottom';
    ctx.shadowColor='rgba(0,0,0,0.45)';
    ctx.shadowBlur=4;
    ctx.fillText(s.text,s.x,y);
    ctx.shadowBlur=0;
    ctx.globalAlpha=1;
    if(age>=s.life)textSplashes.splice(i,1);
  }
}

// === METEOR (圆锥状流星) ===
class Meteor{
  constructor(){this.reset();this.trail=[];}
  reset(){
    this.x=rand(0.05*W,0.95*W);
    this.y=rand(-0.1*H,0.05*H);
    const angle=rand(Math.PI/6,Math.PI/3); // 30°~60°
    const speed = rand(0.15,0.3)*(H/1000);
    this.vx=Math.cos(angle)*speed*(Math.random()<0.5?-1:1);
    this.vy=Math.sin(angle)*speed;
    this.len=rand(80,140);
    this.trail=[];
  }
  update(dt,time){
    this.trail.push({x:this.x,y:this.y});
    if(this.trail.length>25)this.trail.shift();
    this.x+=this.vx*dt;this.y+=this.vy*dt;
    const ground=groundY();
    if(this.y>=ground){
      createTextSplashesAt(this.x,ground-10);
      this.reset();
    }
  }
  draw(){
    if(this.trail.length < 2) return;

    const headRadius = Math.max(1, H*0.007);

    // 绘制尾迹（锥形）
    ctx.save();
    for(let i=0; i<this.trail.length-1; i++){
        const p1 = this.trail[i];
        const p2 = this.trail[i+1];

        // 从尾到头，线条宽度渐增，最粗等于流星直径
        const t = i / (this.trail.length-1); // 0尾 1头
        ctx.lineWidth = headRadius * 2 * t; // 尾细头粗

        // 渐变颜色
        const alpha = t;
        ctx.strokeStyle = `rgba(255,255,255,${alpha})`;

        ctx.beginPath();
        ctx.moveTo(p1.x,p1.y);
        ctx.lineTo(p2.x,p2.y);
        ctx.stroke();
    }
    ctx.restore();

    // 绘制流星头部光晕
    const last = this.trail[this.trail.length-1];
    const headGrad = ctx.createRadialGradient(last.x,last.y,0,last.x,last.y,headRadius*2);
    headGrad.addColorStop(0,'rgba(255,255,255,1)');
    headGrad.addColorStop(0.3,'rgba(255,255,220,0.9)');
    headGrad.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = headGrad;
    ctx.beginPath();
    ctx.arc(last.x,last.y,headRadius,0,Math.PI*2);
    ctx.fill();
}
}

// === COUPLE ===
// === COUPLE 优化版：站在草地上 ===
function drawCouple(){
  const ground = groundY(); // 草地顶部
  const cx = W*0.5;
  const baseY = ground; // 人物底部在草地上
  const scale = H/1080; // 按屏幕比例缩放

  // --- 新郎 ---
  ctx.save();
  const groomHeadR = 28*scale;
  const groomBodyH = 140*scale;
  const groomFeetY = baseY;
  const groomHeadY = groomFeetY - groomBodyH - groomHeadR;

  // 身体
  ctx.fillStyle='#0b3d91';
  ctx.beginPath();
  ctx.moveTo(cx-100*W/1920, groomFeetY - groomBodyH);
  ctx.lineTo(cx-125*W/1920, groomFeetY);
  ctx.lineTo(cx-75*W/1920, groomFeetY);
  ctx.closePath();
  ctx.fill();

  // 头
  ctx.fillStyle='#fddbb0';
  ctx.beginPath();
  ctx.arc(cx-100*W/1920, groomHeadY, groomHeadR, 0, Math.PI*2);
  ctx.fill();

  // 领带
  ctx.fillStyle='#ff0000';
  ctx.beginPath();
  ctx.moveTo(cx-102*W/1920, groomHeadY + 20*scale);
  ctx.lineTo(cx-98*W/1920, groomHeadY + 20*scale);
  ctx.lineTo(cx-100*W/1920, groomHeadY + 50*scale);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // --- 新娘 ---
  ctx.save();
  const brideHeadR = 28*scale;
  const brideBodyH = 140*scale;
  const brideFeetY = baseY;
  const brideHeadY = brideFeetY - brideBodyH - brideHeadR;

  // 婚纱身体
  ctx.fillStyle='#fffaf0';
  ctx.beginPath();
  ctx.moveTo(cx+100*W/1920, brideFeetY - brideBodyH);
  ctx.lineTo(cx+65*W/1920, brideFeetY);
  ctx.lineTo(cx+135*W/1920, brideFeetY);
  ctx.closePath();
  ctx.fill();

  // 婚纱裙摆
  ctx.beginPath();
  ctx.moveTo(cx+65*W/1920, brideFeetY);
  ctx.bezierCurveTo(cx+70*W/1920, brideFeetY+100*scale, 
                    cx+130*W/1920, brideFeetY+100*scale, 
                    cx+135*W/1920, brideFeetY);
  ctx.fill();

  // 头
  ctx.fillStyle='#fddbb0';
  ctx.beginPath();
  ctx.arc(cx+100*W/1920, brideHeadY, brideHeadR, 0, Math.PI*2);
  ctx.fill();

  // 头纱
  ctx.strokeStyle='rgba(255,255,255,0.7)';
  ctx.lineWidth=3;
  ctx.beginPath();
  ctx.moveTo(cx+100*W/1920, brideHeadY);
  ctx.lineTo(cx+120*W/1920, brideHeadY-80*scale);
  ctx.stroke();

  // 花束
  ctx.fillStyle='pink';
  ctx.beginPath();
  ctx.arc(cx+130*W/1920, brideFeetY - brideBodyH/2, 16*scale, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

// === INIT ===
const trees=[new CherryTree(0.22,0.75,0.26),new CherryTree(0.7,0.75,0.26),new CherryTree(0.48,0.75,0.28)];
let meteors=[];for(let i=0;i<6;i++)meteors.push(new Meteor());

// === LOOP ===
let lastTime=performance.now();
function loop(now){
  const dt=Math.max(1,now-lastTime);lastTime=now;
  ctx.clearRect(0,0,W,H);

  // sky gradient
  const skyGrad=ctx.createLinearGradient(0,0,0,H*0.6);
  skyGrad.addColorStop(0,'#0b0c2f');skyGrad.addColorStop(1,'#2a3a50');
  ctx.fillStyle=skyGrad;ctx.fillRect(0,0,W,H*0.6);

  // stars
  for(const s of stars){
    s.alpha+=s.dA*dt;if(s.alpha<=0.05||s.alpha>=1.0)s.dA*=-1;
    ctx.fillStyle=`rgba(255,255,255,${Math.max(0,Math.min(1,s.alpha))})`;
    ctx.beginPath();ctx.arc(s.xr*W,s.yr*H,s.r,0,Math.PI*2);ctx.fill();
  }

  // moon
  const moonX=W*0.8,moonY=H*0.15,moonR=Math.max(24,H*0.05);
  const mg=ctx.createRadialGradient(moonX,moonY,0,moonX,moonY,moonR);
  mg.addColorStop(0,'#ffffff');mg.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle=mg;ctx.beginPath();ctx.arc(moonX,moonY,moonR,0,Math.PI*2);ctx.fill();

  drawLake();
  for(const t of trees)t.draw(dt,now);

  ctx.fillStyle='#1a2e14';ctx.fillRect(0,groundY(),W,H-groundY());
  updateAndDrawFallenFlowers(dt,now);
  drawCouple();

  for(const m of meteors){m.update(dt,now);m.draw();}
  if(Math.random()<0.008)meteors.push(new Meteor());
  if(meteors.length>22)meteors.splice(0,meteors.length-18);

  updateAndDrawTextSplashes(dt,now);
  drawGrass();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>